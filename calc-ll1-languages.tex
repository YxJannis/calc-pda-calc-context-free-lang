\section{Calc-LL(1) Languages}
\label{3.0}
\subsection{Definition}
\label{3.1}
Informally, Calc-LL(1) languages can be described by looking at both Calc-regular languages as well as conventional LL(1) languages. LL(1) languages are a great instrument to guarantee a relatively simple and efficient parsing procedure. Calc-regular languages, on the other hand, provide us with the tools to represent languages using length-prefix format without variable nesting. Calc-LL(1) languages aim to merge the characteristics of these two language classes into a completely new class. This language class should then be able to parse length-prefix notation formats even with variable nesting, additionally employing the efficient, table-based parsing procedure that is given by LL(1).\\\\
As a matter of fact, many data serialization languages or formats currently in use that employ variable nesting are usually parsed using basic LL(1) parsing techniques and should therefore be classified as context-free. On a more detailed look, though, one can see inconsistencies that lead to these languages not actually being context-free as of Chomsky's strict definition \cite{Chomsky-Hierarchy}, as proven in theorem 2 in Grosch et al.'s paper \cite{Calc-regular-paper}.  This leads us to the conclusion that these languages form a separate, slightly different language class, which we establish and call Calc-LL(1).\\\\
As of this thesis, an exact formal definition of Calc-LL(1) languages has not yet been established. This thesis focuses on creating a working automaton model for Calc-LL(1) languages as well as presenting a grammar based on extended Backus-Naur form \cite{EBNF} that matches the definition from the automaton.
\subsection{Conventional LL(1)-Languages and Parsing Techniques}
\label{3.2}
An LL($k$) parser is a top-down parser for a subset of deterministic context-free languages. Subsequently, these parsers can be represented in a theoretical model by deterministic pushdown automatons. LL($k$) parsers parse from \textbf{L}eft to right and perform a \textbf{L}eftmost derivation of the input. Importantly, these parsers use $k$ tokens of look-ahead. This means that the parser can see at maximum $k$ of the upcoming tokens in the message to be parsed and decide their next step upon this knowledge \cite{Parsing-Techniques-(lookahead)}. LL(1) parsers therefore have a look-ahead of one token. They are the simplest form of LL($k)$ parsers and can parse LL(1) grammars respectively. Crucially, these LL(1) grammars are all deterministic.
\\\\
Parse tables are an important component of LL($k$) parsers due to the look-ahead. A parse table $M$ for any LL(1) grammar $G=\{N,\Sigma,P,S\}$\footnote{$N$ = non-terminal symbols, $\Sigma$ = terminal symbols, $P$ = productions, $S$ = starting non-terminal symbol.} is a two-dimensional table including all terminal symbols $\sigma \in \Sigma$ and all non-terminal symbols $A \in N$ as rows and columns respectively (or vice versa). Each table cell $m_{A,\sigma} \in M$ may either be empty or contain at most one production rule $p \in P$. Therefore, detecting if a grammar is LL(1) can be done by constructing the parse table. If every table cell has \textbf{at most} one entry, the grammar corresponding to the parse table is an LL(1) grammar. If a cell $m_{A,\sigma} \in M$ does contain some $p \in P$, this $p$ will mark the production rule that shall be executed next if the current non-terminal symbol on the stack is $A$ and the look-ahead token is $\sigma$. This table-parsed parsing guarantees determinism and additionally makes the procedure rather efficient, as the computation of the table can be done in advance and table-lookups are inexpensive. Also, since LL($k$) parsing can be carried out by a \textit{predictive recursive descent parser}\footnote{Predictive parsing is only possible for the class of LL($k$) grammars \cite{recursive-descent-parser}.} \cite{recursive-descent-parser}, backtracking is not required. This feeds into the efficiency of LL($k$) parsing, as parsing languages that require backtracking in recursive descent parsers may require exponential time \cite{recursive-descent-parser}. When the parser chooses one production in a parse table cell with regards to $A$ and $\sigma$, it knows with perfect certainty that this is the only possible production that can be executed in this situation. Therefore, the need for backtracking is eliminated.\\\\
All these properties make the LL(1) parsing technique a perfect fit for our purpose of parsing variably nested length-prefix languages. Of course, as this is a highly practical endeavour, the determinism trait is required. The look-ahead is also important for our cause, as we will see in more detail in chapter \hyperref[4.0]{4}. Without knowing about the upcoming token, the parser sometimes cannot make a deterministic decision when parsing some length-prefix formats. For more in-depth information about conventional parsing techniques, the book 'Parsing Techniques' \cite{Parsing-Techniques-2} by Grune and Jacobs is highly recommended.
\subsection{Calc-LL(1) Parsing and Split Parse Tables}
\label{3.3}
In a project at Bauhaus-Universit√§t Weimar which was conducted prior to the research this thesis presents, a practical example of a Calc-LL(1) parser was implemented for netstrings. Also, a definition for so-called 'split parse tables' was introduced, specifically tailored for Calc-LL(1) languages. We will not go into detail much more about these findings, but they are publicly available on github in \cite{Calc-LL(1)-project}. The repository includes the parser for netstrings with detailed error-handling written in python, a generator for split parse tables for formal grammars also written in python and a report about these findings.
